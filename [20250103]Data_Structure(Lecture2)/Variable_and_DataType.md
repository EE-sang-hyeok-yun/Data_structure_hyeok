# Variable & Data Type

## 변수란?

변수(variable)란 프로그램에서 데이터를 저장하고 관리하기 위한 이름 붙은 메모리 공간.

변수를 사용하면 데이터를 재사용하거나 처리할 수 있다.

변수를 선언하여 값을 대입하여 사용한다. 일종의 값을 담는 바구니라고 생각하면 된다.

## 변수의 구성 요소

### 1. **자료형 (Data Type)**

- **의미:**
    - 변수에 저장할 데이터의 종류를 정의하며, 메모리 크기와 저장 방식을 결정.
- **역할:**
    - 할당되는 메모리 크기를 지정.
    - 변수에 저장할 수 있는 값의 범위와 형식을 결정.
    - 컴파일러가 변수에 대해 적절한 연산을 수행하도록 함.

### 2. **변수의 메모리 주소**

- **의미:**
    - 변수가 저장된 메모리 공간의 고유 식별자.
- **역할:**
    - 프로그래머가 메모리에 직접 접근할 수 있도록 주소 제공.
    - 포인터를 통해 메모리를 동적으로 조작하거나 참조 가능.
- **`&` 연산자:**
    - `&` 연산자를 사용하여 변수의 주소를 확인할 수 있다.
    
    ```c
    int number = 100; 
    // 정수형 변수 num 선언
    // 100 으로 초기화
    int* numAddress = &number; 
    // 정수형 포인터 변수 numAddress 선언
    // number의 주소로 초기화
    
    printf("%d\n", number);
    printf("%p\n", numAddress);
    //100
    //000000B8C714F5D4
    ```
    

### 3. **실제 메모리 (값이 저장되는 공간)**

- **의미:** 자료형에 따라 할당된 메모리 공간에 실제 데이터가 저장.
- **역할:** 프로그램이 변수의 값을 저장하고 조작하는 데 사용.

## 자료형

### Integer

### 1. 정수형 변수의 저장 방식

### 1) 2’s Complement 표현법

2의 보수는 각 비트를 반전시킨 후, 여기에 1을 더하여 음수를 표현한다. 

- **예시:** `-5` 를 2의 보수로 나타내보자.
    1. 양수 5의 8 비트 이진수 표현:  `0000 0101` 
    2. 모든 비트를 반전 (1의 보수): `1111 1010`
    3. 1을 더하여 2의 보수를 구함: `1111 1011`
- **2의 보수 특징**
    - 첫 번째 비트는 양수 음수를 나타낸다.
    - 두 번째 비트부터 숫자 정보
    - 1의 보수 + 1
- **예시: 20 `0001 0100`**
    
    
    | Bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    |  | +/- | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
    | 숫자 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |
- **예시: -20 `1110 1011` + `1`  = `11101100`**
    
    
    | Bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    | --- | --- | --- | --- | --- | --- | --- | --- | --- |
    |  | +/- | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
    | 숫자 | 1 | 1 | 1 | 0 | 1 | 1 | 0 | 0 |

2의 보수 방식은 0을 유일하게 표현할 수 있다.

음수와 양수의 계산이 간단하다. 

덧셈과 뺄셈이 더 직관적으로 이루어진다. 

### 2) 2’s Complement 덧셈 방법

2의 보수에서 덧셈을 수행하는 방법은 1의 보수와 달리 단순히 **이진수 덧셈만 수행하면 되는 방식이다**. 캐리를 다시 더해줄 필요가 없기 때문에 2의 보수 방식은 컴퓨터 시스템에서 널리 사용된다.

2의 보수에서 뺄셈을 수행할 때는 빼는 숫자의 부호를 반대로 한 뒤, 덧셈을 수행한다. 덧셈으로 두 수를 단순히 더한 후, 초과하는 캐리 비트가 있으면 무시하면 된다.

### 예시 1: -5와 3을 더하기 (8비트)

1. **이진수 표현**:
    - 양수 5를 8비트로 표현: `0000 0101`
    - 5의 2의 보수 (-5): `1111 1011` (1의 보수 `1111 1010` 에 1을 더함)
    - 3을 8비트로 표현: `0000 0011`
2. **2의 보수 덧셈 수행**:
    
    ```
      1111 1011  (-5)
    + 0000 0011  (+3)
    --------------
    1 1111 1110  (9비트, 초과된 캐리 비트 무시)
    ```
    
3. **결과 해석**:
    - 결과는 `1111 1110` 로, 이는 -2을 의미한다.
    - 따라서, -5와 3을 더한 결과는 -2.

### 예시 2: 2의 보수로 -3에서 2 빼기 (8비트)

1. **이진수 표현**:
    - 양수 3을 8비트로 표현: `0000 0011`
    - 3의 2의 보수 (-3): `1111 1101` (1의 보수 `1111 1100` 에 1을 더함)
    - 양수 2를 8비트로 표현: `0000 0010`
    - 2의 2의 보수 (-2): `1111 1110` (1의 보수 `1111 1101` 에 1을 더함)
2. **2의 보수 덧셈 수행**:
    
    ```
      1111 1101  (-3)
    + 1111 1110  (-2)
    --------------
    1 1111 1011  (9비트, 초과된 캐리 비트 무시)
    ```
    
3. **결과 해석**:
    - 결과는 `1111 1011`로, 이는 2의 보수에서 -5를 나타낸다.
    - 따라서, -3과 -2를 더한 결과는 -5.

### **2의 보수와 1의 보수 뎃셈 차이 (그림)**

![스크린샷(78).png](스크린샷(78).png)

### **3) 메모리에서 저장**

- 정수형 변수는 메모리에 **바이트 단위**로 저장된다.
- 작은 크기의 자료형(`short`)은 적은 바이트만 사용하며, 큰 자료형(`long long`)은 더 많은 바이트를 사용.

### 2. 정수형 변수의 종류와 크기

| 자료형 | 메모리 크기 | 값의 범위 (signed) | 값의 범위 (unsigned) |
| --- | --- | --- | --- |
| `int` | 4 bytes | -2,147,483,648 ~ 2,147,483,647 | 0 ~ 4,294,967,295 |
| `short` | 2 bytes | -32,768 ~ 32,767 | 0 ~ 65,535 |
| `long` | 4 bytes (32-bit 시스템) 또는 8 bytes (64-bit 시스템) | -2,147,483,648 ~ 2,147,483,647 (32-bit) | 0 ~ 4,294,967,295 |
| `long long` | 8 bytes | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 0 ~ 18,446,744,073,709,551,615 |

### 3. **signed / unsigned**

- **`signed` (기본값):** 음수와 양수를 모두 저장.
- **`unsigned`:** 양수만 저장하며, 저장 가능한 값의 범위가 2배로 확장.

```c
signed int x = -100;  // 음수 가능, 생략 가능
unsigned int y = 100; // 양수만 가능
```

### 4. 예시 코드

```c
int number = -31415;
short shortNumber = -1234;
long longNumber = -314159265;
long long greatNumber = -3141592653589;
// signed 정수 선언과 초기화
// 크기는 다음과 같다 
// int -> 4
// short -> 2
// long -> 4
// long long -> 8

unsigned u_number = 31415;
unsigned short u_shortNumber = 1234;
unsigned long u_longNumber = 314159265;
unsigned long long u_greatNumber = 3141592653589;
// unsigned 정수 선언과 초기화
// 크기는 다음과 같다 
// unsigned (int) -> 4
// unsigned short -> 2
// unsigned long -> 4
// unsigned long long -> 8
```